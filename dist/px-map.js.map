{"version":3,"sources":["px-map.es6.js"],"names":["PxMapRootComponent","is","properties","elementInst","type","Object","notify","readOnly","crs","String","value","lat","Number","lng","zoom","observer","maxZoom","minZoom","bounds","Array","fitToMarkers","Boolean","flexToSize","reflectToAttribute","window","requestAnimationFrame","_drawMap","bind","listen","unlisten","fitFn","_getAllMarkerGeoms","isValid","fitBounds","debounce","L","LatLngBounds","eachLayer","layer","options","icon","markerGeom","getLatLng","extend","_markerCluster","getBounds","clusterBounds","retries","maxRetries","x","_drawX","parentElement","clientWidth","y","_drawY","clientHeight","mapDrawEl","Polymer","dom","root","querySelector","map","zoomControl","scopeSubtree","$","_setElementInst","fire","mapMoveFn","_handleMapMove","_mapMoveHandlerFn","on","_updateMapView","_fitMapToMakers","latLng","getCenter","getZoom","updateFn","setView","mapBounds","markers","contains","push","marker","parentCluster","getVisibleParent","_behaviors","PxMapBehavior","Layer","ParentLayer"],"mappings":"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","file":"px-map.js","sourcesContent":["(function() {\n  'use strict';\n\n  class PxMapRootComponent {\n    beforeRegister() {\n      this.is = 'px-map';\n      this.properties = {\n        /**\n         * The active map instance. Currently, the only mapping base library offered\n         * is Leaflet, so this will be a reference to the `L.map` that is displaying\n         * all the relevant map data.\n         *\n         * This is exposed as a framework-level building block to allow binding of the\n         * map instance to other elements that call methods on it. Do not call methods\n         * directly on the map instance. Use the web component APIs provided by\n         * `px-map` and its subcomponents to manipulate the map. If you call methods\n         * directly on this instance, your data model may become out-of-sync.\n         *\n         * This map instance will need to be passed down to subcomponents so they\n         * can draw themselves on the map. Use declarative data binding to pass it.\n         * For example:\n         *\n         * ```\n         * <px-map map-instance=\"{{map}}\">\n         *   <px-map-overlay-layer map-instance=\"{{map}}\"></px-map-overlay-layer>\n         * </px-map>\n         * ```\n         *\n         * You can also use the `DistributeProperties` behavior to automatically\n         * distribute the map instance to all light DOM children as they are added,\n         * and keep the map instance up-to-date.\n         *\n         * @type {Object}\n         */\n        elementInst: {\n          type: Object,\n          notify: true,\n          readOnly: true\n        },\n\n        // ---------------------------------------------------------------------\n        // CONFIGURES THE VIEW SETTINGS FOR THE ACTIVE MAP\n        // ---------------------------------------------------------------------\n\n        /**\n         * The Coordinate Reference System to use when drawing the map. Leave the\n         * default if you're not sure what this means.\n         *\n         * @type {String}\n         */\n        crs: {\n          type: String,\n          value: 'L.CRS.EPSG3857',\n          notify: true\n        },\n\n        /**\n         * The latitude of the active map center. Can be used to set or update\n         * the center of the map, or read from after the user moves the map to\n         * get updated coordinates.\n         *\n         * @type {Number}\n         */\n        lat: {\n          type: Number,\n          value: 37.7672375,\n          notify: true\n        },\n\n        /**\n         * The longitude of the active map center. Can be used to set or update\n         * the center of the map, or read from after the user moves the map to\n         * get updated coordinates.\n         *\n         * @type {Number}\n         */\n        lng: {\n          type: Number,\n          value: -121.9584131,\n          notify: true\n        },\n\n        /**\n         * The zoom level of the active map. Can be used to set or update\n         * the zoom level of the map, or read from after the user changes the\n         * map zoom level to an updated value.\n         *\n         * @type {Number}\n         */\n        zoom: {\n          type: Number,\n          value: 10,\n          notify: true,\n          observer: '_updateMapView'\n        },\n\n        /**\n         * The maximum zoom level for the active map. Will be applied to all\n         * layers of the map.\n         *\n         * @type {Number}\n         */\n        maxZoom: {\n          type: Number,\n          value: 18\n        },\n\n        /**\n         * The minimum zoom level for the active map. Will be applied to all\n         * layers of the map.\n         *\n         * @type {Number}\n         */\n        minZoom: {\n          type: Number,\n        },\n\n        /**\n         * Restricts the view of the map to a given geographical boundary. The\n         * user will be bounced back if they attempt to pan outside the view.\n         * Disabled by default, letting the user pan to any point on the map.\n         *\n         * Pass an array of `<LatLng>` values like the following:\n         *\n         *        [40.712, -74.227], [40.774, -74.125]\n         *\n         * @type {Array}\n         */\n        bounds: {\n          type: Array\n        },\n\n        // ---------------------------------------------------------------------\n        // ENABLES FEATURES THAT CHANGE THE MAP BEHAVIOR\n        // ---------------------------------------------------------------------\n\n        /**\n         * Automatically changes the visible bounds of the map to fit all\n         * markers placed on it.\n         *\n         * @type {Object}\n         */\n        fitToMarkers: {\n          type: Boolean,\n          value: false,\n          observer: '_fitMapToMakers'\n        },\n\n        // ---------------------------------------------------------------------\n        // TELL THE MAP HOW TO RESIZE\n        // ---------------------------------------------------------------------\n\n        /**\n         * Uses flexbox to set the size of the map. Set the parent container\n         * to use `display: flex;` in your CSS and the map will automatically\n         * fill the container's available height and width.\n         *\n         * @type {Boolean}\n         */\n        flexToSize: {\n          type: Boolean,\n          reflectToAttribute: true,\n          value: false\n        }\n      };\n    }\n\n    /* Behaviors to import for this component */\n    get behaviors() {\n      return this._behaviors || (this._behaviors = [PxMapBehavior.Layer, PxMapBehavior.ParentLayer]);\n    }\n\n    set behaviors(value) {\n      this._behaviors = value;\n    }\n\n    attached() {\n      window.requestAnimationFrame(this._drawMap.bind(this,0,10));\n\n      if (this.fitToMarkers) {\n        this.listen(this, 'px-map-marker-add', '_fitMapToMakers');\n        this.listen(this, 'px-map-marker-group-add', '_fitMapToMakers');\n      }\n    }\n\n    detached() {\n      if (this.fitToMarkers) {\n        this.unlisten(this, 'px-map-marker-add', '_fitMapToMakers');\n        this.listen(this, 'px-map-marker-group-add', '_fitMapToMakers');\n      }\n    }\n\n    /**\n     * If the map is configured to fit itself to markers, iterates over all\n     * layers to find marker and ensures they fit in the view.\n     *\n     * This functio will be called when:\n     * 1. The `fitToMarkers` property is defined\n     * 2. Any marker fires a 'px-map-marker-add' event that bubbles up to the map\n     * 3. The map is first drawn\n     */\n    _fitMapToMakers() {\n      if (this.elementInst && this.fitToMarkers) {\n\n        const fitFn = () => {\n          const bounds = this._getAllMarkerGeoms();\n          if (!bounds.isValid || !bounds.isValid()) return;\n          this.elementInst.fitBounds(bounds);\n        };\n\n        this.debounce('fit-map-to-markers', fitFn, 1);\n      }\n    }\n\n    /**\n     * Iterates over all markers attached to the map and returns an array of\n     * <L.LatLng> instances with the geometry.\n     *\n     * @return {Array}\n     */\n    _getAllMarkerGeoms() {\n      // Create a new bounds and extend with the map center point\n      let bounds = new L.LatLngBounds();\n      // bounds.extend(L.latLng([this.lat, this.lng]));\n\n      // Loop over the layers\n      this.elementInst.eachLayer((layer) => {\n        // Markers have a `layer.options.icon` set\n        if (layer.options && layer.options.icon) {\n          let markerGeom = layer.getLatLng();\n          bounds.extend(markerGeom);\n        }\n\n        // Markers in a PruneCluster have a `layer.Cluster._markers` array with length\n        if (layer._markerCluster && layer.getBounds) {\n          let clusterBounds = layer.getBounds();\n          bounds.extend(clusterBounds);\n        }\n      });\n      return bounds;\n    }\n\n    /**\n     * Attemps to draw the map, if it hasn't already been drawn. If the parent\n     * has no height, throws it back into the stack to draw on the next\n     * animation frame.\n     */\n    _drawMap(retries=0, maxRetries=10) {\n      const x = this._drawX = this.parentElement.clientWidth;\n      const y = this._drawY = this.parentElement.clientHeight;\n\n      if (!x || !y) {\n        // Try again, if there are any retries left\n        if (retries < maxRetries) {\n          window.requestAnimationFrame(this._drawMap.bind(this, (retries+1), maxRetries));\n        }\n        return;\n      }\n\n      // Try to find an initialized map instance. If there is none, create it.\n      if (!this.elementInst) {\n        const mapDrawEl = Polymer.dom(this.root).querySelector('#map');\n        let map = L.map(mapDrawEl, {\n          minZoom: this.minZoom,\n          maxZoom: this.maxZoom,\n          zoomControl: false\n        });\n\n        // @TODO: This is a shim for browsers without shadow DOM. We need to\n        // re-append the `#map` element or it won't get the 'style-scope' CSS\n        // classes needed to style it or its children. That's bad. When the\n        // polyfill is updated or support is cut for browsers without shadow\n        // DOM, this should be removed.\n        // Polymer.dom(this.root).appendChild(mapDrawEl);\n        this.scopeSubtree(this.$.map, true);\n\n        // Attach to the read-only `elementInst`\n        this._setElementInst(map);\n        this.fire('px-map-layer-instance-created');\n\n        // Bind map move listeners\n        const mapMoveFn = this._handleMapMove.bind(this);\n        this._mapMoveHandlerFn = map.on('moveend', mapMoveFn)\n      }\n\n      // Ensure a tile layer is applied to the map\n      // L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n      //   attribution: 'Map data &copy; <a href=\"http://openstreetmap.org\">OpenStreetMap</a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>, Imagery &copy; <a href=\"http://mapbox.com\">Mapbox</a>',\n      //   maxZoom: 18\n      // }).addTo(this.elementInst);\n\n      // Set the view from current defaults\n      this._updateMapView();\n\n      // Try to fit to map markers if the `fitToMarkers` attribute was set\n      this._fitMapToMakers();\n    }\n\n    _handleMapMove() {\n      let latLng = this.elementInst.getCenter();\n      let zoom = this.elementInst.getZoom();\n\n      this.fire('px-map-moved', {\n        latLng: latLng,\n        lat: latLng.lat,\n        lng: latLng.lng,\n        zoom: zoom\n      });\n    }\n\n    /**\n     * Called when the `lat`, `lng`, or `zoom` is set or updated. Sets the active\n     * map center to the new values.\n     */\n    _updateMapView() {\n      if (this.elementInst) {\n        let updateFn = () => { this.elementInst.setView([this.lat, this.lng], this.zoom) };\n        this.debounce('update-map-view', updateFn, 1);\n      }\n    }\n\n    getVisibleMarkers() {\n      const mapBounds = this.elementInst.getBounds();\n      let markers = [];\n\n      // Loop over the layers\n      this.elementInst.eachLayer((layer) => {\n        // Markers have a `layer.options.icon` set\n        if (layer.options && layer.options.icon) {\n          // Only push markers that are visible\n          if (mapBounds.contains(layer.getLatLng())) {\n            markers.push(layer);\n          }\n        }\n\n        // Marker clusters have a `_markerCluster` key\n        if (layer._markerCluster) {\n          layer.eachLayer((marker) => {\n            // Only push markers that are visible\n            let parentCluster = layer.getVisibleParent(marker);\n            if (parentCluster && mapBounds.contains(parentCluster.getLatLng())) {\n              markers.push(marker);\n            }\n          })\n        }\n      });\n\n      return markers;\n    }\n\n  }\n\n  /* Register this element with the Polymer constructor */\n  Polymer(PxMapRootComponent);\n})()\n"]}